# Лабораторна робота №1 (Варіант 1)

Цей проект демонструє просту систему управління складом, написану на Python. Він зосереджений на дотриманні різних принципів програмної інженерії для забезпечення підтримуваності, гнучкості та надійності.

### Принципи програмування

1.  **DRY (Don't Repeat Yourself - Не повторюйся):**
    *   Інтерфейси, такі як `Money`, `Product`, `Warehouse` та `Reporting` (визначені у файлах [money.py](./logic/money.py), [product.py](./logic/product.py), [warehouse.py](./logic/warehouse.py) та [reporting.py](./logic/reporting.py) відповідно), гарантують, що загальна функціональність не дублюється в різних класах.
    *   Абстрактні методи в цих інтерфейсах забезпечують узгоджену реалізацію в різних конкретних класах.
    *   Також всі файли обʼєднані одним класом [logic](./logic/), задля легшого імпортування та використання класів.

2.  **KISS (Keep It Simple, Stupid - Роби простіше):**
    *   Код розділений на окремі файли для кращої організації та читабельності.
    *   Кожен клас має одну відповідальність, дотримуючись принципу єдиної відповідальності (Single Responsibility Principle, SRP).
    *   Використовуються чіткі правила іменування для класів, методів та змінних.

3.  **Принципи SOLID:**
    *   **Single Responsibility Principle (SRP - Принцип єдиної відповідальності):** Кожен клас має одну відповідальність. Наприклад, `Money` обробляє валюту, `Product` представляє продукт, `Warehouse` керує запасами, а `Reporting` генерує звіти.
    *   **Open/Closed Principle (OCP - Принцип відкритості/закритості):** Система відкрита для розширення, але закрита для модифікації. Нові типи продуктів або формати звітів можна додавати без зміни існуючого коду, реалізуючи відповідні інтерфейси.
    *   **Liskov Substitution Principle (LSP - Принцип підстановки Ліскова):** Конкретні класи, такі як `SimpleMoney`, `BasicProduct`, `SimpleWarehouse` та `BasicReporting`, можна використовувати взаємозамінно з їхніми відповідними інтерфейсами без впливу на коректність програми (див. `main.py`).
    *   **Interface Segregation Principle (ISP - Принцип розділення інтерфейсу):** Інтерфейси є деталізованими, містять лише методи, що стосуються конкретної поведінки.
    *   **Dependency Inversion Principle (DIP - Принцип інверсії залежностей):** Модулі високого рівня (`Reporting`) залежать від абстракцій (інтерфейс `Warehouse`), а не від конкретних реалізацій (`SimpleWarehouse`).

4.  **YAGNI (You Aren't Gonna Need It - Вам це не знадобиться):**
    *   Код зосереджений на основних функціях для управління складом та уникає непотрібної складності.
    *   Такі функції, як знижка на ціну в `Product`, опущені, оскільки вони наразі не потрібні.

5.  **Composition Over Inheritance (Композиція замість спадкування):**
    *   Клас `Reporting` використовує композицію для включення об'єкта `Warehouse`, що дозволяє гнучко вибирати різні реалізації складу.

6.  **Program to Interfaces, Not Implementations (Програмування на інтерфейсах, а не на реалізаціях):**
    *   Клас `Reporting` взаємодіє з `Warehouse` через його інтерфейс, а не через конкретну реалізацію (`SimpleWarehouse`). Це дозволяє легко замінювати різні типи складів у майбутньому.

7.  **Fail Fast (Швидке виявлення помилок):**
    *   В `SimpleWarehouse.add_item` виконується перевірка введених даних, щоб запобігти додаванню товарів з негативною кількістю, забезпечуючи раннє виявлення помилок.